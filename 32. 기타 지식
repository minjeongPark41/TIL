was, admin 폴더 이름의 비밀


was (Web Application Server)
서버 클라이언트의 요청이 있을 때 내부의 프로그램을 통해 결과를 만들어내고 이것을 다시 클라이언트에 전달해주는 역할을 하는 웹 컨테이너.


admin server
특정 도메인에 대한 구성 제공

ㅡㅡㅡㅡㅡ
const router = express.Router();
함수 호출한 결과를 router라는 변수로 객체를 담은 것.
express객체 .Router() 함수 호출하면 → 지금 Router 새로 만드는 것 (초기화)
-> 그 결과 객체를 return 하는데, 그걸 router 변수 안에 담은 것.

변수 = 담을 수 있는 그릇
-> 즉, router 변수 안에 객체를 담은 것

ㅡㅡㅡㅡㅡ

<instaerror.js>
module.exports = function InstaError(messag,...
클래스 만들어서 exports 객체에 싣음
만들고자 하는 모듈을 파일로 만들고 exports 객체의 속성이나 메소드를 정의해주면 모듈을 만들 수 있음
<users.js>
const InstaError = require('../../common/instaerror');
만들어진 모듈을 전역 함수 require()를 이용하여 추출 → 파일을 불러와 결과 값을 변수 에 대입
exports 객체에 추가해줬던 속성이나 메소드를 사용할 수 있게 됨
throw new InstaError(req.__(STRINGS.ERR_USER_NOT_FOUND), 404);
new class인 셈으로 객체를 만든 것

ㅡㅡㅡㅡㅡ
함수 레이어가
<user.js>에 a 함수
함수 타고 들어가서 b 함수
또 함수 타고 들어가서 c 함수
→ 이렇게 있다고 할 때, c 함수에서 오류를 내면 ‘맨 처음’ 레이어인 <user.js>의
try-catch 부분의 catch 부분에서 ‘항상’ 처리해준다.

ㅡㅡㅡㅡㅡ
return cache.get(cacheKey);
나는 그냥 ‘캐시를 리턴해주네’ 하고 넘어갔었는데, 그러다보니 코드를 해석하는 부분에 있어서 오해가 나타나 지장을 주었음
→ 정확한 해석 : ‘cacheKey를 key로 cache에서 get해오는 값’

ㅡㅡㅡㅡㅡ
	Q. const uidSocial = req.body.UID_SOCIAL;
에서 body란 어떤 body인가.
→ body의 종류 (1) request body (2) response body
→ 여기서는 request body (요청받을 때 정보가 있는 body ↔︎ 응답해줄 때의 정보가 있는 body)


→ response body는 res.json({ user, jwt: UserAuthenticator.getJWTToken(user) }); 이때 사용하는 body. 주석이 붙여넣기가 안되었는데 주석까지 적으면 res.json(body:{위에 내용})임

ㅡㅡㅡㅡㅡ
	sandbox.stub이 하는 기능
기존의 것이 호출되지 않게 해줌
실제 함수를 바꿔서 조작 가능 (전달되는 파라미터 값을 ‘조작’하여 테스트 수행 가능) - 맞음.
힌트) class, method 이름, 그리고 세번째 인자를 보내줌으로서 더 뭔가를 하게 

ㅡㅡㅡㅡㅡ
통합 테스트
(같은 맥락에서 쓰이는 것 중에서)
BDD(Behaviour Driven Development)
단위 테스트
로직이 복잡할 때 사용
‘하나의 컨텍스트’
라우터 레벨, 포함된 함수들을 하나하나 다 mock했을 때

원래 정석으로 테스트를 한다면
라우터, 서비스, 모델 (이 3개가 unit 레벨) 별로,
안에 들어있는 함수들 다 mock 처리해서는 테스트 각각 하고 (=unit 테스트)
라우터, 서비스, 모델을 ‘다' 통합해서 ‘통합 테스트’를 해주는 것

-> 너무 투자가 크다.
그래서 '우리 회사’는 라우터 단위를 통합 테스트로 해준다.
- 1) db 2) authorize만 mock 처리

ㅡㅡㅡㅡㅡ

내 테스트코드에서의 '큰' 문제였던 것 2개
테스트 하려는 함수를 mock 처리 해준 것
이전에 작성했던 테스트 코드 (4-7번째줄)

const result = sandbox.stub(dbHelper, 'promisedQuery').callsFake((conn) => {
            return {name : 'park'}
        });
sandbox.stub(User, 'findByLoginMethodAndUid').callsFake(() => {
           const user = new User();
           user.name = result.name;
        });
        User.findByLoginMethodAndUid(undefined, loginMethod, uidSocial);
 
이 때 나의 생각 : findByLoginMethodAndUid 함수 안의 모든 함수들을 ‘다' mock 처리 해주어야 한다고 생각
-> mock 처리해줄건 ‘외부’에서 가지고 오는 것들.
-> const user = new User();
user.NAME = rows[0].NAME;
객체 생성하고, 그 안에 ‘불러온 데이터’ 값을 '넣어주는 행위’는 findByLoginMethodAndUid의 일! 그러니 4-7번째줄처럼 mock을 하는 건 올바르지 않음.


2. 변경된 코드를 테스트 하지 않음.
Q. 우리가 테스트 하려고 하는게 무엇인가 : '/login/facebook'
→ 라우터를 호출하고 있는데, 현재 내 코드는 모델을 호출하며 테스트 중
(실제 코드에서 뭐가 변경이 되어 오류가 나도, 내가 작성한 테스트 코드는 그걸 반영하지 못하고 계속 passing하며 돌아가게 될 것)
→ 라우터 단위의 통합테스트로 바꾸기

ㅡㅡㅡㅡㅡ

이건 내가 처음에 작성해줬던 잘못된 테스트코드
 
 const result = sandbox.stub(dbHelper, 'promisedQuery').callsFake((conn) => {
      return { name: 'park' };
    });
    const user = await User.findByLoginMethodAndUid(undefined, loginMethod, uidSocial);
    console.log(user);
  });

→ 에러 : TypeError: Cannot read property 'NAME' of undefined
→ undefined'의' name property를 읽을 수 없다는 뜻


실제 코드 : user.NAME = rows[0].NAME;
즉, rows[0]을 읽을 수가 없다는 것.
-> rows는? promisedQuery를 통해 가지고 온 값. 그리고 그 값은 내가 mock으로 처리를 해줬지. {name : ‘park’}이라고
잘못된 부분 1) 배열이 아니기에 rows[0]을 읽을 수가 없는 것
->
 
1return [name:'park']
잘못된 부분 2) 배열 안에 저렇게 넣어서 key값을 가지고 올 수가 있나? 배열 안에는 뭐가 올 수 있나? ('다' 올 수 있다. 즉, 딕셔너리도 올 수 있다.) + NAME이라고 실제 코드가 준 것처럼 해야함
->
 
1return [{NAME:'park'}]


함수 호출 결과 (user)
 

 


최종 테스트 코드 작성
→ user.NAME.should.be.eql('park');

ㅡㅡㅡㅡㅡㅡ
컨벤셔 관련된

(내가 참고 소스 코드를 보지 않아서 멋대로 코드를 작성했었는데) 컨벤션에 위반하는 코드를 작성했을 시에는, 명확한 이유가 있어야 함.
- 폴더 구조 맞지 않았음. (설정 코드 관련한건 기존 회사 코드는 다 common 안에 있었는데, 나는 sequelize 폴더를 새롭게 만들어줌)
- 나는 init 명령어로 저절로 생긴 폴더이지만 config 폴더명으로 환경 설정을 해주려 했는대, 기존 회사 코드에서는 env 폴더명으로 관리함
- class명을 나는 snake식으로 적어주었는데 회사에서 클래스명은 Pascal식
‘저절로’ 작성되는 것들 (라이브러리나 식)은 여기서 적용 x
-> “auto DDL을 하려했다면 was에서 하면 했지, 지금은 was의 side 프로젝트인데 적용x”
