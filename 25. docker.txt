// docker intro

내 컴퓨터에서 어떤 어플리케이션을 만들기 위해서는, 여러 운영 체제의 여러 sw를 깔아야 함.


한 대의 컴퓨터 안에서 각각의 app을 '격리된 환경에서' 실행

이 때 운영체제가 설치된 컴퓨터 - host

host에서 실행되는 격리된 각각의 실행 환경 - container 

- 각각의 container에는 운영체제 전체가 설치되어 있는게 아니라, 앱이 실행되는데 필요한 라이브러리와 실행 파일들만 들어있음

 

이미 설치된 운영체제를 공유하기에 무엇인가를 설치할 필요도 없고, 운영체제가 하나이기에 속도도 느려지지 않음. (저장 장치 용량도 아낄 수 있음)

// docker 설치

2강. 설치
- Linux 운영 체제 위에서 돌아가는 것


만약 내 컴퓨터가 Linux 운영체제가 아니라면, 가상 머신을 설치해서 사용

- 그럼에도 불구하고 사용하는 이유는 docker를 사용하면 그 편리성이 어마어마하기 때문임

 

터미널에서 docker images 하고 에러가 뜨지 않으면 성공적으로 명령어로 제어할 수 있는 환경이라는 증거

// 3강. 이미지 pull


어플을 다운 받는 app store 	docker에서 필요한 sw를 다운 받는 docker hub
다운 받은 'program'	다운 받은 'image'
program을 실행하는 것 	image를 실행하는 것
 

잘 다운 받았는지 확인하기 위해서는 docker images 눌러서 확인 

// 4강. 컨테이너 run 

"하나의 이미지는 여러 컨테이너를 만들 수 있다."
 

맨 위에 컨테이너 하나를 실행시켜보고, 맨 아래 터미널에서 docker ps 하니 만들어진게 하나 뜬 것 

두번째 터미널에 컨테이너를 run 하는데 옵션으로 이름주기를 해서는 ws2 컨테이너를 또 만들어주니 -> 맨 아래 터미널에서 확인 시 하나 더 만들어진 것을 확인 가능


stop 하고 docker ps를 눌러보니 ws2가 사라진 것을 확인 가능. 


하지만, stop 해줬다고 삭제되는 것이 아님. 

docker ps -a를 눌러보면 여전히 ws2가 있는 것을 확인 가능.

 
다시 시작하려면 docker strart [컨테이너 이름]

그런데 아까랑은 다르게 log가 나오지 않음. 

다시 log를 보고 싶다면 ~ 


다시 log가 나오는 것을 확인 가능


'실시간 변화되는' log를 계속 확인하고 싶다면 옵션 -f 주기


컨테이너를 삭제하고 싶다면 docker rm


docker rm ws2를 해서 w2를 삭제해주려 했는데 오류가 남.

이유 : 현재 '실행중인' 컨테이너는 이렇게 삭제가 안 됨. 


이렇게 stop을 해주고 난 후에 삭제해줘야 한다. 

이건 별로 중요한 건 아님
실행중인걸 강제로 삭제하고 싶을 때는 옵션으로 --force를 붙여준다. 


이미지를 삭제할 때는 docker images로 리스트를 보고 이름을 확인한 다음에, docker rmi [이름]을 적어주면 된다. 

ㅡㅡㅡㅡㅡ

5강. 네트워크
 

web server가 사용하기 위해서는 두 대의 컴퓨터가 필요

데이터가 저장된 공간 - file system라고 부르겠다. 


[도커가 없을 때] 

[도커가 있을 때]

도커가 없을 때는 '웹 서버'를 직접 설치했지만, docker를 이용하면 웹 서버가 container에 설치된다. (이미지를 httpd를 이용하기로 했다면 docker run httpd)

이 container가  설치된 운영체제 = docker host 

하나의 docker host에는 여러가지 컨테이너가 있을 수 있음
docker host와 container는 각각 독립적인 실행환경이기 때문에, 독립적인 port와 file system을 가지고 있다. 


웹 브라우저에서 웹 서버로 접근을 하면 접근이 되지 않는다. 

이유 : 현재 host와 container는 연결이 끊겨져 있기 때문

-> host의 80번 포트와 containier의 80번 포트를 연결시켜준다. 

 
명령어 docker run -p 80:80 httpd

앞에가 host, 뒤에가 container 포트


이런걸 port forwarding이라고 함.



Q. 만약에 port가 8000번으로 바뀐다면? 


8081로 들어오면 80 (포트의 컨테이너에) 연결시키겠다. 

ㅡㅡㅡㅡㅡ
6강. 명령어 실행


docker exec ws3(컨테이너 이름) pwd (명령어)를 하면

-> 이 컨테이너를 대상으로 명령어를 실행한게 됨

 

🌟



'지속적으로' 해당 컨테이너를 대상으로 명령어를 작성하려면 

 

docker exec ws3(컨테이너 이름) /bin/sh (뒤에 이걸 붙이면 bin shell을 실행하게 된다. bash 넣어서 이거 부를수도) 

- bin shell의 역할은 사용자가 적은 명령어를 받아서 운영체제에 전달해준다.

-> 근데 이렇게만 치면 아무일도 일어나지 않는다. (엔터를 치자마자 연결이 끊어져서) 

-> 계속 연결을 지속하려면 -i 옵션을 준다. 그리고 -t 옵션도 같이 주는게 좋다. 



운영체제에 대한 이해가 필요하다.
 

docker exec -it ws3(컨테이너 이름) /bin/sh 

- 엔터를 누르면 # 이 나오는데, 이제 이 옆에 '그냥' pwd 등 명령어를 입력하면 해당 컨테이너를 대상으로 명령어가 실행되게 되는 것

 

// 컨테이너 연결을 끊고 싶으면 

exit

 

index.html을 수정해보자.



이건 이미지 httpd 기준.
 

먼저 index.html 파일 위치를 찾자. 

찾은 다음에, nano를 켜서 수정해주려 했는데... 켜지지 않음. 

- 이런 기능도 다 넣으면 용량이 커지기 때문

 

apt update 

apt install nano

nano index.html -> 이제서야 수정 가능

ㅡㅡㅡㅡㅡ

7강. 호스트와 컨테이너의 파일 시스템 연결

 

컨테이너 내의 파일을 '직접' 수정하면 위험한 일이 발생한다.

만약 컨테이너가 사라지면 내가 수정해준 것들도 같이 날라가게 되는 것.



컨테이너의 파일 시스템과 host의 파일 시스템을 연결해준다.

-> 버전 및 백업관리, 수정 등이 편해지게 된다. 

 

host의 8888 포트와 container의 80 포트를 연결.

v 옵션 사용. 볼륨의 약자

  -v syntax combines all the options together in one field

Desktop 이하 htdocs 디렉토리와 (:) 컨테이너 안에서 웹페이지를 찾도록 약속된 디렉토리인 /user/loca/apach2/htdocs/를 연결시킴

 

이러면 host 내 파일을 수정하면, host 와 연결된 container 내 파일도 바뀌어서는 화면에 보이게 된다. 